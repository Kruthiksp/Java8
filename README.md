# Java8
Solving one Java8 questions daily starting from very basic to advance covering all the features.

<h2>Daily Problem Statements</h2>
<pre>
01. Given a list of integers, use Java 8 Stream API to filter out the even numbers and collect them into a new list.
02. Given a list of integers, use Java 8 Stream API and map() to square each number and collect the results into a new list.
03. Given a list of integers,
    Filter only the odd numbers
    Square each of those odd numbers
    Collect the result into a new list.
04. Given a list of lowercase strings, use Java 8 Stream and map() to convert each string to uppercase and collect the result into a new list.
05. Given a list of strings, sort them in ascending order of their lengths using Java 8 features.
06. Given a list of Person Object,
    Sort the list of Person objects by age in ascending order
    Then by name in alphabetical order if ages are equal.
07. Given a list of Product Object,
    Filter the products that cost more than ₹1000
    Collect the result into a new List
    Print the filtered list.
08. Given a list of Product Object,
    Convert this list into a Map<String, Double> where
        -> Key = Product name
        -> Value = Product price
    If the product names are duplicated
        -> Use  "Merge Function".
09. Given a Map<String, Integer> representing products and their stock quantities
    Filter products where the stock is less than 100.
    Sort the result by stock quantity (ascending).
    Collect into a new LinkedHashMap (to maintain sort order).
    Print the result.
10. Given a list of Transaction objects
	Group the transactions by category
	Find the total amount spent in each category
	Store the result in a Map<String, Double>
	Print the final grouped totals
11. Given a list of Order objects.
    Each order contains a list of Items.
    create a List<String> containing the names of all items from all orders.
12. Given a list of Department objects.
    Each department has a name and a list of employees.
    From the list of departments
    -> Extract names of employees who have a salary greater than ₹50,000
    -> Avoid duplicates (assume multiple departments can have employees with the same name).
    -> Sort the names alphabetically.
    -> Collect into a List<String>.
13. You are given a list of Department objects. Each Department has a list of Employee objects.
	Get a Map where:
		Key: Department name
		Value: List of names of employees in that department who earn more than ₹60,000
	The employee names should be sorted alphabetically.
14. You are given a list of Order objects.
    Flatten all items from all orders
	Group the items by their name
	Calculate the total price for each item name
	Store the result in a Map<String, Double> where key = item name, value = total price
15. Given a list of Book objects, group the books by author and then collect the book titles (as a list) for each author.
16. You are given a list of Department objects. 
        Each department has a name and a list of Employee objects.
        Each employee has a name, department, and salary
    From all employees in all departments:
        Group employees by department name.
        For each department, find the highest-paid employee.
        Return a Map<String, Employee> where key is department name, and value is the highest-paid employee of that department.	
17. You are given a list of Transaction objects.
    Each transaction has: category, paymentMethod, amount.
        Group the transactions by category.
        Then group each category’s transactions by paymentMethod.
        Sum the total amount spent per payment method per category.
18. You are given a list of Product objects,
	Each with a name and a price.(Some products may have the same name but different prices.)
    Group the products into a Map<String, Double> where 
        key -> product name
        value -> average price for that product name.
19. You are given a list of Order objects. Each Order contains a list of Items.
    Generate a Map<String, Double> where:
        key -> item name
        value -> total revenue generated by that item(price*quantity)
20. You are given a list of Department objects. Each department has a name and a list of Employee objects. Each employee has a name and salary.	
	Find the department name that has the highest average salary.
21. You are given a list of Order objects. Each Order contains a list of Items.
    Compute the total quantity sold for each item category across all orders.
22. Given a list of Student objects, each having:
    Group the students by gradeLevel, and within each grade, group them by subject, and calculate the average marks for each subject.
23. You have a list of Transaction objects:
    create a map where:
        Key -> City name
        Value -> List of transaction types in that city where the total amount is greater than 1000
24. Given a list of employees, find the average salary for each gender per department.
25. Given a List of Order Objects
    -> From a given List<Order>, group the orders by city,
    -> Inside each city, further group by category,
    -> For each category, calculate the total sales amount,
    -> Sort the categories in descending order of sales within each city.
26. Given a List of Transaction Objects
    -> Filter transactions that happened in 2023 only.
    -> Group these transactions by city.
    -> For each city, find the transaction with the maximum amount.
    -> Finally, sort the result by the highest transaction amount (descending order).
27. Given a list of Employee objects.
    -> Group employees by city and then by department.
    -> For each department in each city, find the average salary.
    -> Sort the departments in descending order of their overall average salary.
28. Given a List of Product Objects
    -> Group the products by category.
    -> For each category, find the product with the highest rating.
    -> Sort the categories by average price (descending).
29. Given a list of Employee objects
    -> Find the average salary of employees for each department.
    -> For each department, find the highest-paid employee.
    -> Sort the departments by average salary in descending order and collect the result in a LinkedHashMap where
        -> key = department
        -> value = a Map.Entry<Double, Employee> (average salary, top employee).
30. given a list of Book objects
    Group the books by genre.
    For each genre:
        Find the average price of books.
        Find the most recently published book.
    Sort the genres by average price in descending order
31. Given a List of Movie Objects.
    Group movies by genre.
    For each genre, calculate the average rating.
    Find the highest-rated movie in each genre.
    Sort genres by their average rating (descending) and display results in the format:
    	Genre -> Average Rating | Top Movie Title
32. Given a List of Employee Objects.
    Partition employees into two groups:
    	-> Those who joined before 2018
    	-> Those who joined in or after 2018
    For each partition, collect the names of employees as a comma-separated string.
33. Given a list of Order objects 
    Group orders by city
    For each city, calculate the total delivered amount (status = "DELIVERED").
    From those, find the city with the maximum delivered amount.
34. Given list of Order Objects
    Consider only the orders with status = "DELIVERED".
    For each city, find the category that has the highest total sales amount.
    Print results like
    city -> category (Total amount)
35. Given a list of Student objects
	Group students by their department.
	For each department, find the average GPA.
	Also, find the top student (highest GPA) in each department.
	Finally, sort the departments by average GPA (descending order) and print:
		Department -> Average GPA | Top Student
36. Given a list of Transaction objects, 
    Group them by customerName and find:
    Total transaction amount per customer.
    Highest transaction per customer.
    Print customers sorted by their total transaction amount (descending), along with their highest transaction.
37. Given a list of Employee objects
	Group employees by department and find the total salary per department.
	From each department, find the employee with the lowest salary.
	Print departments sorted by total salary (descending) along with the employee having the lowest salary in that department.
38. Given a list of Transaction objects
    Find the total amount of all CREDIT transactions.
    Get the list of transactions greater than 1000.
    Find the transaction with the maximum amount.
39. Given a list of integers
    -> Use a Predicate to filter and print only even numbers.
    -> Use a Function to square each number and collect results into a new list.
    -> Use a Consumer to print each element of the squared list.
    -> Use a Supplier to generate a random number between 1–100.
40. Use Predicate to filter employees whose names:
    -> Start with "A" or "D".
    -> And have length greater than 3.
    Use Function chaining to:
    -> Convert each name to uppercase.
    -> Then append " - Employee".
    Use Consumer chaining to print each processed name in two ways:
    -> First just print the name.
    -> Then print "Processed: <name>".
41. Given a list of numbers:
    -> Use a static method reference to check if a number is even.
    -> Use an instance method reference to print each number.
    -> Use a constructor reference to convert the list of strings into a list of Employee objects.
42. Given a method:
    -> Wrap the result of getEmailByUsername() in an Optional.
    -> Print the email if present, otherwise print "Email not found".
    -> Use orElseGet() to return a default email ("default@example.com").
    -> Use map() to transform the email to uppercase if it exists.
43. Given a list of employees:
    -> For each employee, safely get their email using Optional.ofNullable().
        If email is missing, return "no-email@company.com".
    -> Find the first employee whose email starts with "c" (case-insensitive).
        Use stream + findFirst() which returns Optional<Employee>.
        If found, print their email in uppercase, otherwise "No employee found".
    -> Count how many employees actually have an email (non-null).
44. Given a List of User Objects:
    -> Safely get the city name of a user
        If city not present, return "City not available".
    -> Exttract all the cities ignoring the null ones.
    -> Print the first city that starts with "B", or "No city found".
45. Given a List of Employee Objects.
    -> Group employees by department
    -> Find the average salary of each department.
    -> Partition employees into high earners (salary > 50,000) and others.
46. Given a list of transactions:
    -> Find the total amount of all transactions using Collectors.reducing.
    -> Find the transaction with the maximum amount.
    -> Use Collectors.summarizingDouble to get count, sum, min, average, and max of transaction amounts.
47. Given a list of Integers.
    -> Calculate the sum using a sequential stream and measure execution time.
    -> Calculate the sum using a parallel stream and measure execution time.
    -> Compare performance and explain when parallel streams are beneficial.
48. Given a List of Integer.
    -> Find all prime numbers from the list.
    -> Use both sequential stream and parallel stream to process, and compare their performance.
    -> Print the time taken for each.
49. Generate all prime numbers up to N
    -> Collect the primes into a List.
    -> Print the total count of primes.
    -> Print the first 20 primes as a sample.
    -> Compare execution time with your Day 48 prime-check approach.
50. Given a List of Employee Objects.
    -> Group employees by department using Collectors.groupingBy.
    -> Find the average salary per department.
    -> Find the highest-paid employee per department.
    -> Collect all employee names into a comma-separated string.
51. Given a List of Person Objects.
    Partition people into 2 groups
        -> Minors 
        -> Adults
    Get IntSummaryStatistics for ages.
    Collect all unique ages into a Set.
52. Given a list of User Objects.
    Extract all unique email addresses from the list of users using Streams + flatMap().
    Print them in sorted order.
53. Given a list of Transaction objects
	Calculate the total credited amount and total debited amount separately.
	Find the highest transaction amount.
	Find the user with the maximum total transaction amount (sum of all their transactions).
	Create a comma-separated string of all unique transaction types.
54. Find the first order with status = "NEW".
	Find any order with status = "COMPLETED".
	Calculate the total revenue from all COMPLETED orders.
	Partition orders into completed vs not completed using partitioningBy.
55. Given a List of Transaction Objects.
    Find Total Transaction Amount and Maximum Transaction using teeing.
56. Given a List of Employee Objects.
	Group employees by department.
	For each department, compute:
		-> The total salary.
		-> The employee with the highest salary.
	Return the result as a Map<String, Map<String, Object>>
57. Given a list of products:
	Group products by category.
    For each category:
        -> Collect all product names into a comma-separated String (e.g., "TV, Laptop, Phone").
        -> Find the average price.
    Return a Map<String, Map<String, Object>> like this
58. Create Custom Collector to collect Department and its total salary into a Map<String, Double>
59. Given a List of Order Objects.
	Group orders by their status.
	For each status, calculate:
		-> Total Revenue (sum of amount)
		-> List of unique customer names
		-> List of all purchased items (flattened, no duplicates)
	Return the result as a Map<Status, Map<String, Object>>.
60. Given a group of Employee Objects.
	Group employees by department and within each department:
		-> Find the highest paid employee.
		-> Find the average salary.
		-> Find the most experienced employee.
	Collect the result in a Map<String, Map<String, Object>>, where:
		-> Key = Department name
		-> Value = Map with keys "highestPaid", "averageSalary", "mostExperienced".
61. Given a List of Employee Objects.
    Partition employees into two groups:
		-> Experienced (experience >= 5 years)
		-> Less Experienced (experience < 5 years)
	For each partition, calculate two things at once (use teeing):
		-> Total Salary
		-> Highest Paid Employee
	Return a Map<Boolean, Map<String, Object>>.
62. Given a List of Employee Object.
    Write a Java 8 program that groups employees by their city and, for each city, calculates:
		-> Average salary
		-> List of distinct departments
		-> The name of the most experienced employee in that city
	Return the result as a Map<String, CityReport> where CityReport is a custom class (or record) that holds:
		-> double avgSalary -> Set<String> departments -> Employee mostExperiencedEmp
</pre>

<!-- <h2>Bonus Problem Statements</h2>
<pre>
01. Given a list of Employee Objects,
    Sort the list of Employee objects by department.
02. Given a list of Product Objects,
    find the product with Maximum price.
03. Given a List<Student>,
	extract all unique course names (i.e., no duplicates).
	sort them alphabetically.
	Collect the result into a List<String>.
04. Sort the resulting of Day_18 map by average price in descending order and 
    collect it into a LinkedHashMap to preserve that order?
</pre> -->
